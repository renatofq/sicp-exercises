#+TITLE: 3.3 Exercises

* Exercise 3.12
The following procedure for appending lists was introduced in 2.2.1:

#+begin_src scheme :eval never
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+end_src

Append forms a new list by successively consing the elements of x onto y.  The procedure append! is similar to append, but it is a mutator rather than a constructor.  It appends the lists by splicing them together, modifying the final pair of x so that its cdr is now y.  (It is an error to call append! with an empty x.)

#+begin_src scheme :eval never
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
#+end_src

Here last-pair is a procedure that returns the last pair in its argument:

#+begin_src scheme :eval never
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
#+end_src

Consider the interaction

#+begin_example
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

z
(a b c d)

(cdr x)
⟨response⟩

(define w (append! x y))

w
(a b c d)

(cdr x)
⟨response⟩
#+end_example

What are the missing ⟨response⟩s?  Draw box-and-pointer diagrams to explain your answer.

** Solution
#+begin_example
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

z
$1 = (a b c d)

(cdr x)
$2 = (b)

(define w (append! x y))

w
$3 = (a b c d)

(cdr x)
$4 = (b c d)
#+end_example

*** Box-and-pointer diagram after (define z (append x y))
[[file:annex/3_12-boxes-1.png]]

*** Box-and-pointer diagram after (define w (append! x y))
[[file:annex/3_12-boxes-2.png]]

* Exercise 3.13
Consider the following make-cycle procedure, which uses the last-pair procedure defined in Exercise 3.12:

#+begin_src scheme :eval never
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
#+end_src

Draw a box-and-pointer diagram that shows the structure z created by

#+begin_src scheme :eval never
(define z (make-cycle (list 'a 'b 'c)))
#+end_src

What happens if we try to compute (last-pair z)?

** Solution
*** Box-and-pointer diagram
[[file:annex/3_13-boxes.png]]

*** What happens if we try to compute (last-pair z)?
An infinite recursion will happen

* Exercise 3.14
The following procedure is quite useful, although obscure:

#+begin_src scheme :eval never
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
#+end_src

Loop uses the “temporary” variable temp to hold the old value of the cdr of x, since the set-cdr!  on the next line destroys the cdr.  Explain what mystery does in general.  Suppose v is defined by (define v (list 'a 'b 'c 'd)). Draw the box-and-pointer diagram that represents the list to which v is bound. Suppose that we now evaluate (define w (mystery v)). Draw box-and-pointer diagrams that show the structures v and w after evaluating this expression.  What would be printed as the values of v and w?

** Solution
mystery returns a list in the reversed order while changing the original list which becomes a list containing only the first of its original elements.

*** Box-and-pointer diagram after (define v (list 'a 'b 'c 'd))
[[file:annex/3_14-boxes-1.png]]

*** Box-and-pointer diagram after (define w (mystery v))
[[file:annex/3_14-boxes-2.png]]

* Exercise 3.15
Draw box-and-pointer diagrams to explain the effect of set-to-wow! on the structures z1 and z2 above.

** Solution
[[file:annex/3_15-boxes-1.png]]

[[file:annex/3_15-boxes-2.png]]

* Exercise 3.16
Ben Bitdiddle decides to write a procedure to count the number of pairs in any list structure.  “It’s easy,” he reasons.  “The number of pairs in any structure is the number in the car plus the number in the cdr plus one more to count the current pair.”  So Ben writes the following procedure:

#+begin_src scheme :eval never
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
#+end_src

Show that this procedure is not correct.  In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben’s procedure would return 3; return 4; return 7; never return at all.

** Solution
*** Returns 3
[[file:annex/3_16-boxes-1.png]]

*** Returns 4
[[file:annex/3_16-boxes-2.png]]

*** Returns 7
[[file:annex/3_16-boxes-3.png]]

*** Never returns
[[file:annex/3_16-boxes-4.png]]

* Exercise 3.17
Devise a correct version of the count-pairs procedure of Exercise 3.16 that returns the number of distinct pairs in any structure.  (Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)

** Solution
#+begin_src scheme
;; set operations
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((eq? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (cons x set))

(define (count-pairs x)
  ((let ((set-of-pairs '()))
     (define (count-pairs-helper x)
       (if (or (not (pair? x))
               (element-of-set? x set-of-pairs))
           0
           (begin (set! set-of-pairs (adjoin-set x set-of-pairs))
                  (+ (count-pairs-helper (car x))
                     (count-pairs-helper (cdr x))
                     1))))
     count-pairs-helper)
   x))

(define a-list '(a))
(define a-list-consed (cons a-list a-list))

(test-equal 3 (count-pairs '(a b c)))

;; would return 4 in the previous exercise
(test-equal 3 (count-pairs (cons a-list-consed '())))

;; would return 7 in the previous exercise
(test-equal 3 (count-pairs (cons a-list-consed a-list-consed)))

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)

;; would never return
(test-equal 3 (count-pairs (make-cycle '(a b c))))
#+end_src

* Exercise 3.18
Write a procedure that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive cdrs would go into an infinite loop.  Exercise 3.13 constructed such lists.

** Solution
#+begin_src scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((eq? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (cons x set))

(define (cycle? x)
  (define (cycle-helper x set-of-pairs)
       (cond ((null? x)
              false)
             ((element-of-set? x set-of-pairs)
              true)
             (else
              (cycle-helper (cdr x) (adjoin-set x set-of-pairs)))))
  (cycle-helper x '()))

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)

(define a-list '(a b c))
(test-assert (not (cycle? a-list)))

;; last pair points back to the second one
(make-cycle (cdr a-list))

(test-assert (cycle? a-list))
#+end_src

* Exercise 3.19
Redo Exercise 3.18 using an algorithm that takes only a constant amount of space.  (This requires a very clever idea.)

** Solution
#+begin_src scheme
(define (cycle? l)
  (define (iter slow fast)
    (cond ((null? fast) false)
          ((eq? slow fast) true)
          (else
           (let ((ahead (cdr fast)))
             (cond ((null? ahead) false)
                   ((eq? slow ahead) true)
                   (else
                    (iter (cdr slow) (cdr ahead))))))))
  (if (null? l)
      false
      (iter l (cdr l))))


(define a-list '(a b c d))
(test-assert (not (cycle? a-list)))

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)

;; last pair points back to the second one
(make-cycle (cdr a-list))

(test-assert (cycle? a-list))
#+end_src

* TODO Exercise 3.20
Draw environment diagrams to illustrate the evaluation of the sequence of expressions

#+begin_example
(define x (cons 1 2))
(define z (cons x x))

(set-car! (cdr z) 17)

(car x)
17
#+end_example

using the procedural implementation of pairs given above.  (Compare Exercise 3.11.)

* Exercise 3.21
Ben Bitdiddle decides to test the queue implementation described above.  He types in the procedures to the Lisp interpreter and proceeds to try them out:

#+begin_example
(define q1 (make-queue))

(insert-queue! q1 'a)
((a) a)

(insert-queue! q1 'b)
((a b) b)

(delete-queue! q1)
((b) b)

(delete-queue! q1)
(() b)
#+end_example

“It’s all wrong!” he complains.  “The interpreter’s response shows that the last item is inserted into the queue twice.  And when I delete both items, the second b is still there, so the queue isn’t empty, even though it’s supposed to be.”  Eva Lu Ator suggests that Ben has misunderstood what is happening.  “It’s not that the items are going into the queue twice,” she explains.  “It’s just that the standard Lisp printer doesn’t know how to make sense of the queue representation.  If you want to see the queue printed correctly, you’ll have to define your own print procedure for queues.” Explain what Eva Lu is talking about.  In particular, show why Ben’s examples produce the printed results that they do.  Define a procedure print-queue that takes a queue as input and prints the sequence of items in the queue.

** Solution
The standard printer treats pairs that have cdr pointing to another pair as list. Then, our queue structure is printed as a list with two elements whose first element is a list with all elements of the queue and the second one is the last element of the queue. As the second to last element and the rear-ptr point to the same element, it looks like duplication when printed by the standard printer, but it is not. When all elements got removed from the queue, the rear-ptr was still pointing to the last one, because delete-queue! don't touch the rear-ptr but, if we call empty-queue? it will return true and if we call insert-queue the rear-ptr will be updated accordingly.

#+begin_src scheme
(define (display-queue queue)
  (display "<-")
  (display (front-ptr queue))
  (display "-<")
  (newline))
#+end_src

* Exercise 3.22
Instead of representing a queue as a pair of pointers, we can build a queue as a procedure with local state. The local state will consist of pointers to the beginning and the end of an ordinary list.  Thus, the make-queue procedure will have the form

#+begin_src scheme :eval never
(define (make-queue)
  (let ((front-ptr … )
        (rear-ptr … ))
    ⟨definitions of internal procedures⟩
    (define (dispatch m) …)
    dispatch))
#+end_src

Complete the definition of make-queue and provide implementations of the queue operations using this representation.

** Solution
#+begin_src scheme
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty?)
      (null? front-ptr))
    (define (front)
      (if (empty?)
          (error "FRONT called with an empty queue")
          (car front-ptr)))
    (define (insert! item)
      (let ((new-pair (cons item '())))
        (if (empty?)
            (begin
              (set! front-ptr new-pair)
              (set! rear-ptr new-pair))
            (begin
               (set-cdr! rear-ptr new-pair)
               (set! rear-ptr new-pair)))))
    (define (delete!)
      (if (empty?)
          (error "DELETE! called with an empty queue")
          (set! front-ptr (cdr front-ptr))))
    (define (display-queue)
      (display "<-")
      (display front-ptr)
      (display "-<")
      (newline))
    (define (dispatch m)
      (cond ((eq? 'empty? m) empty?)
            ((eq? 'front m) front)
            ((eq? 'insert! m) insert!)
            ((eq? 'delete! m) delete!)
            ((eq? 'display m) display-queue)
            (else (error "Unknown request: QUEUE" m))))
    dispatch))

(define (empty-queue? queue)
  ((queue 'empty?)))
(define (front-queue queue)
  ((queue 'front)))
(define (insert-queue! queue item)
  ((queue 'insert!) item)
  queue)
(define (delete-queue! queue)
  ((queue 'delete!))
  queue)
(define (display-queue queue)
  ((queue 'display)))

(define q (make-queue))
(test-assert (empty-queue? q))
(insert-queue! q 'a)
(insert-queue! q 'b)
(test-equal 'a (front-queue q))
(delete-queue! q)
(test-equal 'b (front-queue q))
(delete-queue! q)
(test-assert (empty-queue? q))
#+end_src

* Exercise 3.23
A deque (“double-ended queue”) is a sequence in which items can be inserted and deleted at either the front or the rear.  Operations on deques are the constructor make-deque, the predicate empty-deque?, selectors front-deque and rear-deque, and mutators front-insert-deque!, rear-insert-deque!, front-delete-deque!, rear-delete-deque!.  Show how to represent deques using pairs, and give implementations of the operations.  All operations should be accomplished in $\theta(1)$ steps.

** Solution
#+begin_src scheme
;; element of the deque ------------------------------------------------
(define (make-element item)
  (cons item (cons '() '())))

(define (element-item element)
  (car element))

(define (next-element element)
  (cddr element))

(define (previous-element element)
  (cadr element))

(define (link-elements! prev next)
  (set-cdr! (cdr prev) next)
  (set-car! (cdr next) prev))

(define (unlink-elements! prev next)
  (set-cdr! (cdr prev) '())
  (set-car! (cdr next) '()))


;; tests
(define e0 (make-element 'a))

(test-assert (eq? '()
                  (next-element e0)))

(test-assert (eq? '()
                  (previous-element e0)))

(test-assert (eq? 'a
                 (element-item e0)))

(define e1 (make-element 'b))
(link-elements! e0 e1)

(test-assert (eq? e1
                  (next-element e0)))

(test-assert (eq? e0
                  (previous-element e1)))

(unlink-elements! e0 e1)

(test-assert (eq? '()
                  (next-element e0)))

(test-assert (eq? '()
                  (previous-element e1)))

;; deque ---------------------------------------------------------------
(define (front-ptr deque) (car deque))
(define (rear-ptr deque) (cdr deque))
(define (set-front-ptr! deque item)
  (set-car! deque item))
(define (set-rear-ptr! deque item)
  (set-cdr! deque item))

(define (make-deque) (cons '() '()))
(define (empty-deque? deque)
  (null? (front-ptr deque)))

(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT called with an empty deque" deque)
      (car (front-ptr deque))))

(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR called with an empty deque" deque)
      (car (rear-ptr deque))))

(define (front-insert-deque! deque item)
  (let ((new-pair (make-element item)))
    (cond ((empty-deque? deque)
           (set-front-ptr! deque new-pair)
           (set-rear-ptr! deque new-pair)
           deque)
          (else (link-elements! new-pair (front-ptr deque))
                (set-front-ptr! deque new-pair)
                deque))))

(define (rear-insert-deque! deque item)
  (let ((new-pair (make-element item)))
    (cond ((empty-deque? deque)
           (set-front-ptr! deque new-pair)
           (set-rear-ptr! deque new-pair)
           deque)
          (else (link-elements! (rear-ptr deque) new-pair)
                (set-rear-ptr! deque new-pair)
                deque))))

(define (front-delete-deque! deque)
  (cond ((empty-deque? deque)
         (error "DELETE! called with an empty deque" deque))
        (else
         (let ((next (next-element (front-ptr deque))))
           (cond ((null? next)
                  (set-front-ptr! deque '())
                  (set-rear-ptr! deque '()))
                 (else (unlink-elements! (front-ptr deque) next)
                       (set-front-ptr! deque next)))
           deque))))

(define (rear-delete-deque! deque)
  (cond ((empty-deque? deque)
         (error "DELETE! called with an empty deque" deque))
        (else
         (let ((prev (previous-element (rear-ptr deque))))
           (cond ((null? prev)
                  (set-front-ptr! deque '())
                  (set-rear-ptr! deque '()))
                 (else (unlink-elements! prev (rear-ptr deque))
                       (set-rear-ptr! deque prev)))
           deque))))

;; tests
(define q (make-deque))
(test-assert (empty-deque? q))

(front-insert-deque! q 'b)
(front-insert-deque! q 'a)
(rear-insert-deque! q 'c)

(test-assert (not (empty-deque? q)))

(test-assert (eq? 'a
                  (front-deque q)))
(test-assert (eq? 'c
                  (rear-deque q)))

(front-delete-deque! q)

(test-assert (eq? 'b
                  (front-deque q)))
(test-assert (eq? 'c
                  (rear-deque q)))

(rear-delete-deque! q)
(test-assert (eq? 'b
                  (front-deque q)))
(test-assert (eq? 'b
                  (rear-deque q)))

(rear-delete-deque! q)
(test-assert (empty-deque? q))
#+end_src
