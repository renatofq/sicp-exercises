#+TITLE: 3.3 Exercises

* Exercise 3.12
The following procedure for appending lists was introduced in 2.2.1:

#+begin_src scheme :eval never
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+end_src

Append forms a new list by successively consing the elements of x onto y.  The procedure append! is similar to append, but it is a mutator rather than a constructor.  It appends the lists by splicing them together, modifying the final pair of x so that its cdr is now y.  (It is an error to call append! with an empty x.)

#+begin_src scheme :eval never
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
#+end_src

Here last-pair is a procedure that returns the last pair in its argument:

#+begin_src scheme :eval never
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
#+end_src

Consider the interaction

#+begin_example
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

z
(a b c d)

(cdr x)
⟨response⟩

(define w (append! x y))

w
(a b c d)

(cdr x)
⟨response⟩
#+end_example

What are the missing ⟨response⟩s?  Draw box-and-pointer diagrams to explain your answer.

** Solution
#+begin_example
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

z
$1 = (a b c d)

(cdr x)
$2 = (b)

(define w (append! x y))

w
$3 = (a b c d)

(cdr x)
$4 = (b c d)
#+end_example

*** Boxes diagram after (define z (append x y))
file:annex/3_12-boxes-1.png

*** Boxes diagram after (define w (append! x y))
file:annex/3_12-boxes-2.png
