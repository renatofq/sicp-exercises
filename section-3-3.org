#+TITLE: 3.3 Exercises

* Exercise 3.12
The following procedure for appending lists was introduced in 2.2.1:

#+begin_src scheme :eval never
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+end_src

Append forms a new list by successively consing the elements of x onto y.  The procedure append! is similar to append, but it is a mutator rather than a constructor.  It appends the lists by splicing them together, modifying the final pair of x so that its cdr is now y.  (It is an error to call append! with an empty x.)

#+begin_src scheme :eval never
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
#+end_src

Here last-pair is a procedure that returns the last pair in its argument:

#+begin_src scheme :eval never
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
#+end_src

Consider the interaction

#+begin_example
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

z
(a b c d)

(cdr x)
⟨response⟩

(define w (append! x y))

w
(a b c d)

(cdr x)
⟨response⟩
#+end_example

What are the missing ⟨response⟩s?  Draw box-and-pointer diagrams to explain your answer.

** Solution
#+begin_example
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

z
$1 = (a b c d)

(cdr x)
$2 = (b)

(define w (append! x y))

w
$3 = (a b c d)

(cdr x)
$4 = (b c d)
#+end_example

*** Box-and-pointer diagram after (define z (append x y))
[[file:annex/3_12-boxes-1.png]]

*** Box-and-pointer diagram after (define w (append! x y))
[[file:annex/3_12-boxes-2.png]]

* Exercise 3.13
Consider the following make-cycle procedure, which uses the last-pair procedure defined in Exercise 3.12:

#+begin_src scheme :eval never
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
#+end_src

Draw a box-and-pointer diagram that shows the structure z created by

#+begin_src scheme :eval never
(define z (make-cycle (list 'a 'b 'c)))
#+end_src

What happens if we try to compute (last-pair z)?

** Solution
*** Box-and-pointer diagram
[[file:annex/3_13-boxes.png]]

*** What happens if we try to compute (last-pair z)?
An infinite recursion will happen

* Exercise 3.14
The following procedure is quite useful, although obscure:

#+begin_src scheme :eval never
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
#+end_src

Loop uses the “temporary” variable temp to hold the old value of the cdr of x, since the set-cdr!  on the next line destroys the cdr.  Explain what mystery does in general.  Suppose v is defined by (define v (list 'a 'b 'c 'd)). Draw the box-and-pointer diagram that represents the list to which v is bound. Suppose that we now evaluate (define w (mystery v)). Draw box-and-pointer diagrams that show the structures v and w after evaluating this expression.  What would be printed as the values of v and w?

** Solution
mystery returns a list in the reversed order while changing the original list which becomes a list containing only the first of its original elements.

*** Box-and-pointer diagram after (define v (list 'a 'b 'c 'd))
[[file:annex/3_14-boxes-1.png]]

*** Box-and-pointer diagram after (define w (mystery v))
[[file:annex/3_14-boxes-2.png]]
