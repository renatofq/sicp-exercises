#+TITLE: Chapter 2 Exercises

* Exercise 2.1
Define a better version of make-rat that handles both positive and negative arguments. Make-rat should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.

** Solution
#+begin_src scheme
(define (make-rat n d)
  (define (normalize-numerator-signal n d)
  (if (< (* n d) 0)
      (* (- 1) (abs n))
      (abs n)))
  (let* ((nsn (normalize-numerator-signal n d))
        (nsd (abs d))
        (gcd-of-n-and-d (abs (gcd nsn nsd))))
    (cons
     (/ nsn gcd-of-n-and-d)
     (/ nsd gcd-of-n-and-d))))

(test-equal 1     (numer (make-rat 1 3)))
(test-equal (- 1) (numer (make-rat 1 (- 3))))
(test-equal (- 1) (numer (make-rat (- 1) 3)))
(test-equal 1     (numer (make-rat (- 1) (- 3))))

(test-equal 3 (denom (make-rat 1 3)))
(test-equal 3 (denom (make-rat 1 (- 3))))
(test-equal 3 (denom (make-rat (- 1) 3)))
(test-equal 3 (denom (make-rat (- 1) (- 3))))
#+end_src

* Exercise 2.2
Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor make-segment and selectors start-segment and end-segment that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the x coordinate and the y coordinate. Accordingly, specify a constructor make-point and selectors x-point and y-point that define this representation. Finally, using your selectors and constructors, define a procedure midpoint-segment that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you’ll need a way to print points:
#+begin_src scheme :eval never
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
#+end_src

** Solution
#+begin_src scheme
;; point abstraction
(define (make-point x y)
  (cons x y))
(define (x-point point)
  (car point))
(define (y-point point)
  (cdr point))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

;; segment abstraction
(define (make-segment start end)
  (cons start end))
(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (cdr segment))
(define (midpoint-segment segment)
  (make-point
   (average (x-point (start-segment segment))
            (x-point (end-segment segment)))
   (average (y-point (start-segment segment))
            (y-point (end-segment segment)))))

(print-point (midpoint-segment (make-segment (make-point 0 0)
                                             (make-point 8 8))))
#+end_src

* Exercise 2.3
Implement a representation for rectangles in a plane. (Hint: You may want to make use of Exercise 2.2.) In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

** Solution
*** Two point based rectangle
#+begin_src scheme
;; from 2.2
(define (make-point x y)
  (cons x y))
(define (x-point point)
  (car point))
(define (y-point point)
  (cdr point))

;; constructor and selectors
(define (make-rectangle a b)
  (cons a b))
(define (rectangle-height r)
  (abs (-
        (y-point (car r))
        (y-point (cdr r)))))
(define (rectangle-width r)
  (abs (-
        (x-point (car r))
        (x-point (cdr r)))))

;; area and perimeter
(define (rectangle-area r)
  (*
   (rectangle-height r)
   (rectangle-width r)))
(define (rectangle-perimeter r)
  (+
   (* 2 (rectangle-height r))
   (* 2 (rectangle-width r))))

;; tests
(define unitary-rectangle
  (make-rectangle
   (make-point 0 0)
   (make-point 1 1)))

(define phi 1.618033988749)
(define golden-rectangle
  (make-rectangle
   (make-point 0 0)
   (make-point 1 phi)))

(test-equal 1 (rectangle-area unitary-rectangle))
(test-equal 4 (rectangle-perimeter unitary-rectangle))

(test-equal phi (rectangle-area golden-rectangle))
(test-approximate
    (+ 2 (* 2 phi))
    (rectangle-perimeter golden-rectangle)
    0.00000000001)
#+end_src

*** Point, width and height based rectangle
#+begin_src scheme
;; from 2.2
(define (make-point x y)
  (cons x y))
(define (x-point point)
  (car point))
(define (y-point point)
  (cdr point))

;; constructor and selectors
(define (make-rectangle a w h)
  (cons a (cons w h)))
(define (rectangle-width r)
  (car (cdr r)))
(define (rectangle-height r)
  (cdr (cdr r)))

;; area and perimeter. Same as before
(define (rectangle-area r)
  (*
   (rectangle-height r)
   (rectangle-width r)))
(define (rectangle-perimeter r)
  (+
   (* 2 (rectangle-height r))
   (* 2 (rectangle-width r))))

;; tests
(define unitary-rectangle
  (make-rectangle (make-point 0 0) 1 1))

(define phi 1.618033988749)
(define golden-rectangle
  (make-rectangle (make-point 0 0) 1 phi))

(test-equal 1 (rectangle-area unitary-rectangle))
(test-equal 4 (rectangle-perimeter unitary-rectangle))

(test-equal phi (rectangle-area golden-rectangle))
(test-approximate
    (+ 2 (* 2 phi))
    (rectangle-perimeter golden-rectangle)
    0.00000000001)
#+end_src

* Exercise 2.4
Here is an alternative procedural representation of pairs. For this representation, verify that (car (cons x y)) yields x for any objects x and y.
#+begin_src scheme :eval never
(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))
#+end_src
What is the corresponding definition of cdr? (Hint: To verify that this works, make use of the substitution model of 1.1.5.)

** Solution
#+begin_src scheme
;; from exercise formulation
(define (cons x y)
  (lambda (m) (m x y)))

;; cdr
(define (cdr z)
  (z (lambda (p q) q)))

;; test
(test-equal 2 (cdr (cons 1 2)))
#+end_src

Substitution:
#+begin_example
> (cdr (cons 1 2))
> (cdr (lambda (m) (m 1 2)))
> (((lambda (m) (m 1 2)) (lambda (p q) q)))
> ((lambda (p q) q) 1 2)
$1 = 2
#+end_example

* Exercise 2.5
Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair $a$ and $b$ as the integer that is the product $2^a3^b$. Give the corresponding definitions of the procedures cons, car, and cdr.

** Solution
*** TODO missing mathematical demonstration
#+begin_src scheme
(define (cons a b)
  (* (expt 2 a) (expt 3 b)))

(define (factored-by factor n)
    (define (iter n count)
      (if (not (= (remainder n factor) 0))
          count
          (iter (/ n factor) (+ count 1))))
    (iter n 0))

(define (car pair)
  (factored-by 2 pair))
(define (cdr pair)
  (factored-by 3 pair))

(test-equal 1 (car 2))
(test-equal 0 (cdr 2))
(test-equal 0 (car 3))
(test-equal 1 (cdr 3))

(define n (cons 2 3))
(test-equal 2 (car n))
(test-equal 3 (cdr n))

(define m (cons 4 4))
(test-equal 4 (car m))
(test-equal 4 (cdr m))
#+end_src

* Exercise 2.6
In case representing pairs as procedures wasn’t mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as
#+begin_src scheme :eval never
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src
This representation is known as Church numerals, after its inventor, Alonzo Church, the logician who invented the λ-calculus.
Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).

** Solution
#+begin_example
> (define one (add-1 zero))
> (define one (add-1 (lambda (f) (lambda (x) x))))
> (define one (lambda (f)
                (lambda (x)
                  (f (((lambda (f) (lambda (x) x)) f) x)))))
> (define one (lambda (f) (lambda (x) (f ((lambda (x) x) x)))))
> (define one (lambda (f) (lambda (x) (f x))))

> (define two (add-1 one))
> (define two (add-1 (lambda (f) (lambda (x) (f x)))))
> (define two (lambda (f)
                (lambda (x)
                  (f (((lambda (f) (lambda (x) (f x))) f) x)))))
> (define two (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x)))))
> (define two (lambda (f) (lambda (x) (f (f x)))))
#+end_example


#+begin_src scheme
;; Church's numerals are functions that receives a function f and returns
;; another function that receives x. is in the domain of f.
;; The numeral zero is the function that maps f to the identity function.
(define zero (lambda (f) (lambda (x) x)))

;; add-1 is the function that maps a Church's numeral, n, to another
;; numeral. It does so by composing f to the result of f applyed to n,
;; applyed to x. f(n(f)(x)) in standard mathematical notation.
;; By this definition, one and two are the following compositions, as
;; shown before.
(define one  (lambda (f) (lambda (x) (f x))))
(define two  (lambda (f) (lambda (x) (f (f x)))))

;; + is the function that maps two Church's numerals, n and m, to another.
;; Therefore, its result is a function that receives a function f and
;; returns a function of x. This resulting fuction is computed by
;; composing n(f), to the result of m(f)(x). This translates to
;; n(f)(m(f)(x)).
;; Applying f m times and subsequentially f n times to its result, is
;; equivalent to applying f n+m times.
(define (+ n m)
  (lambda (f)
    (lambda (x)
      ((n f) ((m f) x)))))

;; tests
(test-equal 1 ((one inc) 0))                 ;; inc(0)
(test-equal 1 (((+ one zero) inc) 0))        ;; inc(0)
(test-equal 2 (((+ one one) inc) 0))         ;; inc(inc(0))

(test-equal 2 ((two inc) 0))                 ;; inc(inc(0))
(test-equal 2 (((+ two zero) inc) 0))        ;; inc(inc(0))
(test-equal 3 (((+ two one) inc) 0))         ;; inc(inc(inc(0)))

(test-equal 5 (((+ one (+ two two)) inc) 0)) ;; inc(inc(inc(inc(inc(0)))))

(define (double n) (* 2 n))
(test-equal
    (expt 2 4)
  (((+ two two) double) 1)) ;; double(double(double(double(1))))
#+end_src

* Exercises 2.7 to 2.16

* Exercise 2.17
Define a procedure last-pair that returns the list that contains only the last element of a given (nonempty) list:
#+begin_src scheme :eval never
(last-pair (list 23 72 149 34))
(34)
#+end_src

** Solution
#+begin_src scheme
(define (last-pair l)
  (let ((next (cdr l)))
    (if (null? next)
        l
        (last-pair next))))

(test-equal (list 34) (last-pair (list 23 72 149 34)))
#+end_src

* Exercise 2.18
Define a procedure reverse that takes a list as argument and returns a list of the same elements in reverse order:
#+begin_src scheme :eval never
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)
#+end_src

** Solution
#+begin_src scheme
(define (reverse l)
  (define (reverse-iter l result)
    (if (null? l)
        result
        (reverse-iter (cdr l) (cons (car l) result))))
  (reverse-iter l nil))

(test-equal
  (list 25 16 9 4 1)
  (reverse (list 1 4 9 16 25)))
#+end_src

* Exercise 2.19
Consider the change-counting program of 1.2.2. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure first-denomination and partly into the procedure count-change (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.
We want to rewrite the procedure cc so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:
#+begin_src scheme :eval never
(define us-coins
  (list 50 25 10 5 1))
(define uk-coins
  (list 100 50 20 10 5 2 1 0.5))
#+end_src
We could then call cc as follows:
#+begin_src scheme :eval never
(cc 100 us-coins)
292
#+end_src
To do this will require changing the program cc somewhat. It will still have the same form, but it will access its second argument differently, as follows:
#+begin_src scheme :eval never
(define (cc amount coin-values)
  (cond ((= amount 0)
         1)
        ((or (< amount 0)
             (no-more? coin-values))
         0)
        (else
         (+ (cc
             amount
             (except-first-denomination
              coin-values))
            (cc
             (- amount
                (first-denomination
                 coin-values))
             coin-values)))))
#+end_src
Define the procedures first-denomination, except-first-denomination and no-more? in terms of primitive operations on list structures. Does the order of the list coin-values affect the answer produced by cc? Why or why not?

** Solution
The order of coin-values does not affect the answer because the procedure does the calculation trying every combination possible for the coins in the list.

#+begin_src scheme
(define (first-denomination coin-values)
  (car coin-values))
(define (except-first-denomination coin-values)
  (cdr coin-values))
(define (no-more? coin-values)
  (null? coin-values))

;; Tests
(define us-coins
  (list 50 25 10 5 1))
(define uk-coins
  (list 100 50 20 10 5 2 1 0.5))
(define (cc amount coin-values)
  (cond ((= amount 0)
         1)
        ((or (< amount 0)
             (no-more? coin-values))
         0)
        (else
         (+ (cc
             amount
             (except-first-denomination
              coin-values))
            (cc
             (- amount
                (first-denomination
                 coin-values))
             coin-values)))))

(test-equal 292 (cc 100 us-coins))
(test-equal 104561 (cc 100 uk-coins))
#+end_src

* Exercise 2.20
The procedures +, *, and list take arbitrary numbers of arguments. One way to define such procedures is to use define with dotted-tail notation. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter’s value will be a list of any remaining arguments. For instance, given the definition
#+begin_src scheme :eval never
(define (f x y . z) ⟨body⟩)
#+end_src
the procedure f can be called with two or more arguments. If we evaluate
#+begin_src scheme :eval never
(f 1 2 3 4 5 6)
#+end_src
then in the body of f, x will be 1, y will be 2, and z will be the list (3 4 5 6). Given the definition
#+begin_src scheme :eval never
(define (g . w) ⟨body⟩)
#+end_src
the procedure g can be called with zero or more arguments. If we evaluate
#+begin_src scheme :eval never
(g 1 2 3 4 5 6)
#+end_src
then in the body of g, w will be the list (1 2 3 4 5 6).

Use this notation to write a procedure same-parity that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,
#+begin_src scheme :eval never
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)

(same-parity 2 3 4 5 6 7)
(2 4 6)
#+end_src

** Solution
#+begin_src scheme
(define (same-parity . l)
  (define desired-paridity?    ;; not using let to avoid some parens
    (if (even? (car l))
        even?
        odd?))
  (define (recur l)
    (cond ((null? l)
           nil)
          ((desired-paridity? (car l))
           (cons (car l) (recur (cdr l))))
          (else
           (recur (cdr l)))))
  (recur l))

(test-equal
  (list 1 3 5 7)
  (same-parity 1 2 3 4 5 6 7))
(test-equal
  (list 2 4 6)
  (same-parity 2 3 4 5 6 7))
#+end_src

* Exercise 2.21
The procedure square-list takes a list of numbers as argument and returns a list of the squares of those numbers.
#+begin_src scheme :eval never
(square-list (list 1 2 3 4))
(1 4 9 16)
#+end_src
Here are two different definitions of square-list. Complete both of them by filling in the missing expressions:
#+begin_src scheme :eval never
(define (square-list items)
  (if (null? items)
      nil
      (cons ⟨??⟩ ⟨??⟩)))

(define (square-list items)
  (map ⟨??⟩ ⟨??⟩))
#+end_src

** Solution
#+begin_src scheme
(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items)) (square-list (cdr items)))))

(test-equal (list 1 4 9 16)
  (square-list (list 1 2 3 4)))

(define (square-list items)
  (map square items))

(test-equal (list 1 4 9 16)
  (square-list (list 1 2 3 4)))
#+end_src

* Exercise 2.22
Louis Reasoner tries to rewrite the first square-list procedure of Exercise 2.21 so that it evolves an iterative process:
#+begin_src scheme :eval never
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
#+end_src
Unfortunately, defining square-list this way produces the answer list in the reverse order of the one desired. Why?

Louis then tries to fix his bug by interchanging the arguments to cons:
#+begin_src scheme :eval never
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square
                     (car things))))))
  (iter items nil))
#+end_src
This doesn’t work either. Explain.

** Solution
I've made the same mistakes in previous exercises. The first attempt does not work because at first iteration it add the result to answer, which is empty, next he adds the result to the first position of answer and so on, reversing the results. The next attempt builds a structure in the form
((((() . 1) . 4) . 9) . 16)
that is not the expected list structure
(1 . (4 . ( 9 . (16 . ())))).

* Exercise 2.23
The procedure for-each is similar to map. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, for-each just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all—for-each is used with procedures that perform an action, such as printing. For example,
#+begin_src scheme :eval never
(for-each
 (lambda (x) (newline) (display x))
 (list 57 321 88))

57
321
88
#+end_src

The value returned by the call to for-each (not illustrated above) can be something arbitrary, such as true. Give an implementation of for-each.

** Solution
#+begin_src scheme
(define (for-each fn ls)
  (if (null? ls)
      nil
      (let ()
        (fn (car ls))           ;; discarding this value is a side effect?
        (for-each fn (cdr ls)))))

(for-each
 (lambda (x) (newline) (display x))
 (list 57 321 88))
#+end_src

#+RESULTS:
: 
: 57
: 321
: 88

* meta :noexport:
#+PROPERTY: header-args :results output
#+OPTIONS: todo:nil toc:nil num:nil
# Local Variables:
# eval: (olivetti-mode 1)
# eval: (flyspell-mode 1)
# ispell-local-dictionary: "american"
# eval: (advice-add
#        'org-babel-insert-result
#        :filter-args
#        (lambda (args)
#          (let ((result (car args))
#                (result-params (cadr args))
#                (others (cddr args)))
#            (apply 'list
#                   result
#                   (if (or
#                        (string-empty-p result) (not result))
#                       (progn (org-babel-remove-result) '("silent"))
#                     result-params)
#                   others))))
# eval: (add-hook 'geiser-repl-startup-hook
#        (lambda ()
#          (geiser-load-file "chapter-2-defs.scm")))
# End:
