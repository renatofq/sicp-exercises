#+title: 2.5 Exercises

* Exercise 2.77
Louis Reasoner tries to evaluate the expression (magnitude z) where z is the object shown in Figure 2.24.  To his surprise, instead of the answer 5 he gets an error message from apply-generic, saying there is no method for the operation magnitude on the types (complex).  He shows this interaction to Alyssa P. Hacker, who says "The problem is that the complex-number selectors were never defined for complex numbers, just for polar and rectangular numbers.  All you have to do to make this work is add the following to the complex package:"

#+begin_src scheme :eval never
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
#+end_src

Describe in detail why this works.  As an example, trace through all the procedures called in evaluating the expression (magnitude z) where z is the object shown in Figure 2.24.  In particular, how many times is apply-generic invoked?  What procedure is dispatched to in each case?

** Solution
The structure of z is '(complex rectangular 3 . 4), so the type-tag of z is 'complex. The definition of magnitude is:
#+begin_src scheme :eval never
(define (magnitude z)
  (apply-generic 'magnitude z))
#+end_src
Thus when magnitude is called for z it will apply magnitude again to the contents of z, that is '(rectangular 3 . 4). Now, magnitude will apply-generic again to an object which its type-tag is 'rectangular, and then magnitude defined in the rectangular package will be applied to 3 . 4.

* Exercise 2.78
The internal procedures in the scheme-number package are essentially nothing more than calls to the primitive procedures +, -, etc.  It was not possible to use the primitives of the language directly because our type-tag system requires that each data object have a type attached to it.  In fact, however, all Lisp implementations do have a type system, which they use internally.  Primitive predicates such as symbol? and number?  determine whether data objects have particular types.  Modify the definitions of type-tag, contents, and attach-tag from 2.4.2 so that our generic system takes advantage of Scheme's internal type system.  That is to say, the system should work as before except that ordinary numbers should be represented simply as Scheme numbers rather than as pairs whose car is the symbol scheme-number.

** Solution
#+begin_src scheme
(define (attach-tag type-tag contents)
  (if (eq? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))

(define (type-tag datum)
  (cond ((number? datum) 'scheme-number)
        ((pair? datum)
         (car datum))
        (else
         (error "Bad tagged datum: TYPE-TAG"
                datum))))

(define (contents datum)
  (cond ((number? datum) datum)
        ((pair? datum)
         (cdr datum))
        (else
         (error "Bad tagged datum: CONTENTS"
                datum))))
#+end_src

* Exercise 2.79
Define a generic equality predicate equ? that tests the equality of two numbers, and install it in the generic arithmetic package.  This operation should work for ordinary numbers, rational numbers, and complex numbers.

** Solution
#+begin_src scheme
(define (install-equality-package)
  (put 'equ?
       '(scheme-number scheme-number)
       (lambda (x y)
         (= x y)))
  (put 'equ?
       '(rational rational)
       (lambda (x y)
         (and (= (numerator x) (numerator y))
              (= (denominator x) (denominator y)))))
  (put 'equ?
       '(complex complex)
       (lambda (x y)
         (and (= (real-part x) (real-part y))
              (= (imag-part x) (imag-part y)))))
  'done)

(define (equ? x y)
  (apply-generic 'equ? x y))
#+end_src

* Exercise 2.80
Define a generic predicate =zero? that tests if its argument is zero, and install it in the generic arithmetic package.  This operation should work for ordinary numbers, rational numbers, and complex numbers.

** Solution
#+begin_src scheme
(define (install-zero-predicate-package)
  (put '=zero?
       '(scheme-number)
       (lambda (x)
         (= 0 x)))
  (put '=zero?
       '(rational)
       (lambda (x)
         (= 0 (numerator x))))
  (put '=zero?
       '(complex)
       (lambda (x)
         (and (= 0 (real-part x))
              (= 0 (imag-part x)))))
  'done)

(define (=zero? x)
  (apply-generic '=zero? x))
#+end_src
